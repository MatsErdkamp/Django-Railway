from .. import models
from backend.models import GroupPlaylist, GroupMembership, Playlist, Stream, SongContainer, Song, Ranking, GroupRanking
from . import spotify_get_functions, compatibility_functions, error_functions
import spotipy
from .authorization_functions import get_token
from django.utils.timezone import make_aware
from django.contrib.auth.models import User
import datetime
from .utils import set_timeframe
import random


def remix_playlist():
    print("remixing playlist")
    playlist = Playlist.objects.all()[0]

    playlist_spotify = spotify_get_functions.get_playlist(
        user=User.objects.get(username='famerdkamp'), id=playlist.playlist_id)

    for song in playlist_spotify['tracks']['items']:
        artist_uri = song['track']['artists'][0]['uri']

        print("{0:<40.40} {1} {2:<0}".format(song['track']['name'], ' -> ', str(
            random.choice(models.Artist.objects.get(uri=artist_uri).song_set.all()))))


    


def update_playlists(playlists=None, hours=12, limit=5):

    # add constraint with last update & GTE.

    yesterday = make_aware(datetime.datetime.now() -
                           datetime.timedelta(hours=hours))

    if playlists == None:
        outdated_playlists = Playlist.objects.filter(update=True).filter(
            last_update__lte=yesterday).order_by('last_update')
    else:
        outdated_playlists = playlists


    remove_playlist_if_dead(outdated_playlists)

    # outdated_playlists = Playlist.objects.filter(update=True).order_by('last_update')

    print("{} outdated playlists! updating them now...".format(
        len(outdated_playlists)))

    for playlist in outdated_playlists[:limit]:

        user = playlist.user
        user_spotify_playlists = spotify_get_functions.get_spotify_playlists(
            user, rootnote_only=True)

        user_spotify_playlists_ids = [x['id'] for x in user_spotify_playlists]

        if playlist.playlist_id not in user_spotify_playlists_ids:
            print('----playlist not found in the user catalogue; Skipping!')
            continue

        try:

            token = get_token(user)
            extra_data = eval(playlist.extra_data)


            if type(playlist) == GroupPlaylist:
                group = [x.user for x in GroupMembership.objects.filter(group=playlist.group)]
            else:
                group = playlist.members.all()


            new_tracks = get_songs_for_playlist(group=group, timeframe=extra_data['timeframe'],
                                                artist_maximum=extra_data[
                                                    'maximum_per_artist'], release_range=extra_data['release_range'],
                                                energy_range=extra_data['energy_range'], valence_range=extra_data['valence_range'],
                                                danceability_range=extra_data['danceability_range'])


            new_tracks_uris = [x.uri for x in new_tracks]



            token = get_token(user)
            spotipy.Spotify(token).user_playlist_replace_tracks(
                user=user, playlist_id=playlist.playlist_id, tracks=new_tracks_uris)


            dt = datetime.datetime.now()

            description = 'Playlist generated by rootnote.io -- Last updated on ' + \
                dt.strftime('%Y-%m-%d')

            spotipy.Spotify(token).user_playlist_change_details(
                user=user, playlist_id=playlist.playlist_id, description=description)


            if type(playlist) == GroupPlaylist:
                old_songs_list = playlist.groupranking_set.all().values('song__id', 'ranking_position')
            else:
                old_songs_list = playlist.ranking_set.all().values('song__id', 'ranking_position')

            old_songs_dict = {}

            for old_song in old_songs_list:
                old_songs_dict[old_song['song__id']
                               ] = old_song['ranking_position']

            # print(old_songs_dict)

            playlist.songs.clear()
            new_songs_count = 0

            for index, song in enumerate(new_tracks):

                if song.id in old_songs_dict:
                    change_amount = old_songs_dict[song.id] - (index + 1)
                    if change_amount > 0:
                        change_trend = 'up'
                    elif change_amount < 0:
                        change_trend = 'down'
                    else:
                        change_trend = 'constant'
                else:
                    change_amount = None
                    change_trend = 'new'
                    new_songs_count += 1

                
                if type(playlist) == GroupPlaylist:
                    ranking = GroupRanking(song=song, compatibility=song.compatibility, playlist=playlist,
                                    ranking_position=index+1, ranking_change_trend=change_trend, ranking_change_amount=change_amount)
                    ranking.save()
                else:
                    ranking = Ranking(song=song, compatibility=song.compatibility, playlist=playlist,
                                        ranking_position=index+1, ranking_change_trend=change_trend, ranking_change_amount=change_amount)
                    ranking.save()

            playlist.new_entries_amount = new_songs_count
            playlist.last_update = dt
            playlist.save()


        except Exception as e:
            error_functions.send_manual_exception_email(str(e))


def get_songs_for_playlist(group, timeframe, release_range, energy_range, valence_range, danceability_range, limit=100, artist_maximum=None):

    queryset = Stream.objects.active().all()



    queryset = set_timeframe(queryset, timeframe)

    queryset = set_query_range(
        queryset, 'song__album__release_date', release_range[0], release_range[1])

    queryset = set_query_range(
        queryset, 'song__energy', energy_range[0], energy_range[1])

    queryset = set_query_range(
        queryset, 'song__valence', valence_range[0], valence_range[1])

    queryset = set_query_range(
        queryset, 'song__danceability', danceability_range[0], danceability_range[1])

    queryset = queryset.filter(user__in=group)

    songs = compatibility_functions.sort_by_compatibility_logarithmic_max_artists(
        queryset, group, artist_maximum=artist_maximum, limit=limit)

    print("artist maximum: " + str(artist_maximum))
    context = []


    if len(songs) < limit:
        limit = len(songs)

    for item in songs.items():
        try:
            song = SongContainer.objects.get(id=item[0]).master_child_song
            song.compatibility = item[1]

            context.append(song)

        except Exception as e:
            error_functions.send_manual_exception_email(f"{str(e)} --- item[0] == {str(item[0])}")

    return context



def remove_playlist_if_dead(queryset):

    if queryset.count() == 0:
        return None

    for playlist in queryset:

        user = playlist.user
        token = get_token(user)
        
        social = user.social_auth.get(provider='spotify')
        response = spotipy.Spotify(token).user_playlist_is_following(social.uid, playlist.playlist_id, [social.uid])

        if response[0] == False:
            playlist.delete()

        print(response)

        


def set_query_range(queryset, keyword, lower_bound, upper_bound):

    filter = {}
    filter[str(keyword) + '__gte'] = lower_bound
    filter[str(keyword) + '__lte'] = upper_bound

    queryset = queryset.filter(**filter)

    return queryset
